/*
This file was generated by FTE Quake 5612, dated 2020-01-23T18:57:48.352042Z.
This file can be regenerated by issuing the following command:
pr_dumpplatform -ffte -tmenu
Available options:
-Ffte       - target only FTE (optimations and additional extensions)
-Tnq        - dump specifically NQ fields
-Tqw        - dump specifically QW fields
-Tcs        - dump specifically CSQC fields
-Tmenu      - dump specifically menuqc fields
-Fdefines   - generate #defines instead of constants
-Faccessors - use accessors instead of basic types via defines
-O          - write to a different qc file
*/
#pragma noref 1
//#pragma flag enable logicops
#pragma warning error Q101 /*too many parms. The vanilla qcc didn't validate properly, hence why fteqcc normally treats it as a warning.*/
#pragma warning error Q105 /*too few parms. The vanilla qcc didn't validate properly, hence why fteqcc normally treats it as a warning.*/
#pragma warning error Q106 /*assignment to constant/lvalue. Define them as var if you want to initialise something.*/
#pragma warning error Q208 /*system crc unknown. Compatibility goes out of the window if you disable this.*/
#pragma warning disable F211 /*system crc outdated (eg: dp's csqc). Note that this may trigger emulation.*/
#pragma warning enable F301 /*non-utf-8 strings. Think of the foreigners! Also think of text editors that insist on screwing up your char encodings.*/
#pragma warning enable F302 /*uninitialised locals. They usually default to 0 in qc (except in recursive functions), but its still probably a bug*/
#pragma target FTE
#ifndef MENU
#define MENU
#endif
#define FTE_PEXT_SETVIEW /* NQ's svc_setview works correctly even in quakeworld */
#define DP_ENT_SCALE
#define FTE_PEXT_LIGHTSTYLECOL
#define DP_ENT_ALPHA
#define FTE_PEXT_VIEW2
#define FTE_PEXT_ACURATETIMINGS
#define FTE_PEXT_SOUNDDBL
#define FTE_PEXT_FATNESS
#define DP_HALFLIFE_MAP
#define FTE_PEXT_TE_BULLET
#define FTE_PEXT_HULLSIZE
#define FTE_PEXT_MODELDBL
#define FTE_PEXT_ENTITYDBL
#define FTE_PEXT_ENTITYDBL2
#define FTE_PEXT_FLOATCOORDS
#define FTE_PEXT_VWEAP
#define FTE_PEXT_Q2BSP
#define FTE_PEXT_Q3BSP
#define DP_ENT_COLORMOD
#define FTE_HEXEN2
#define FTE_PEXT_SPAWNSTATIC
#define FTE_PEXT_CUSTOMTENTS
#define FTE_PEXT_256PACKETENTITIES
#define TEI_SHOWLMP2
#define DP_GFX_QUAKE3MODELTAGS
#define FTE_PK3DOWNLOADS
#define PEXT_CHUNKEDDOWNLOADS
#define EXT_CSQC_SHARED
#define PEXT_DPFLAGS
#define EXT_CSQC
#define BX_COLOREDTEXT
#define DP_CON_SET /* The 'set' console command exists, and can be used to create/set cvars. */
#define DP_CON_SETA /* The 'seta' console command exists, like the 'set' command, but also marks the cvar for archiving, allowing it to be written into the user's config. Use this command in your default.cfg file. */
#define DP_EF_ADDITIVE
#define DP_EF_BLUE
#define DP_EF_FULLBRIGHT
#define DP_EF_NODEPTHTEST
#define DP_EF_NODRAW
#define DP_EF_NOGUNBOB
#define DP_EF_NOSHADOW
#define DP_EF_RED
#define DP_ENT_CUSTOMCOLORMAP
#define DP_ENT_EXTERIORMODELTOCLIENT
#define DP_ENT_TRAILEFFECTNUM /* self.traileffectnum=particleeffectnum("myeffectname"); can be used to attach a particle trail to the given server entity. This is equivelent to calling trailparticles each frame. */
#define DP_ENT_VIEWMODEL
#define DP_GECKO_SUPPORT
#define DP_GFX_FONTS
#define DP_GFX_SKINFILES
#define DP_GFX_SKYBOX
#define DP_HALFLIFE_MAP_CVAR
#define DP_INPUTBUTTONS
#define DP_LIGHTSTYLE_STATICVALUE
#define DP_LITSUPPORT
#define DP_MONSTERWALK /* MOVETYPE_WALK is valid on non-player entities. Note that only players receive acceleration etc in line with none/bounce/fly/noclip movetypes on the player, thus you will have to provide your own accelerations (incluing gravity) yourself. */
#define DP_MOVETYPEBOUNCEMISSILE
#define DP_MOVETYPEFOLLOW
#define DP_QC_ASINACOSATANATAN2TAN
#define DP_QC_CHANGEPITCH
#define DP_QC_COPYENTITY
#define DP_QC_CRC16
#define DP_QC_CVAR_DEFSTRING
#define DP_QC_CVAR_STRING
#define DP_QC_CVAR_TYPE
#define DP_QC_EDICT_NUM
#define DP_QC_ENTITYDATA
#define DP_QC_ETOS
#define DP_QC_FINDCHAIN
#define DP_QC_FINDCHAINFLOAT
#define DP_QC_FINDFLAGS
#define DP_QC_FINDCHAINFLAGS
#define DP_QC_FINDFLOAT
#define DP_QC_FS_SEARCH
#define DP_QC_GETSURFACE
#define DP_QC_GETSURFACEPOINTATTRIBUTE
#define DP_QC_GETTAGINFO
#define DP_QC_MINMAXBOUND
#define DP_QC_MULTIPLETEMPSTRINGS /* Superseded by DP_QC_UNLIMITEDTEMPSTRINGS. Functions that return a temporary string will not overwrite/destroy previous temporary strings until at least 16 strings are returned (or control returns to the engine). */
#define DP_QC_RANDOMVEC
#define DP_QC_RENDER_SCENE /* clearscene+addentity+setviewprop+renderscene+setmodel are available to menuqc. WARNING: DP advertises this extension without actually supporting it, FTE does actually support it. */
#define DP_QC_SINCOSSQRTPOW
#define DP_QC_SPRINTF /* Provides the sprintf builtin, which allows for rich formatting along the lines of C's function with the same name. Not to be confused with QC's sprint builtin. */
#define DP_QC_STRFTIME
#define DP_QC_STRING_CASE_FUNCTIONS
#define DP_QC_STRINGBUFFERS
#define DP_QC_STRINGCOLORFUNCTIONS
#define DP_QC_STRREPLACE
#define DP_QC_TOKENIZEBYSEPARATOR
#define DP_QC_TRACEBOX
#define DP_QC_TRACETOSS
#define DP_QC_TRACE_MOVETYPE_HITMODEL
#define DP_QC_TRACE_MOVETYPE_WORLDONLY
#define DP_QC_TRACE_MOVETYPES
#define DP_QC_UNLIMITEDTEMPSTRINGS /* Supersedes DP_QC_MULTIPLETEMPSTRINGS, superseded by FTE_QC_PERSISTENTTEMPSTRINGS. Specifies that all temp strings will be valid at least until the QCVM returns. */
#define DP_QC_URI_ESCAPE
#define DP_QC_URI_GET
#define DP_QC_URI_POST
#define DP_QC_VECTOANGLES_WITH_ROLL
#define DP_QC_VECTORVECTORS
#define DP_QC_WHICHPACK
#define DP_QUAKE2_MODEL
#define DP_QUAKE2_SPRITE
#define DP_QUAKE3_MODEL
#define DP_REGISTERCVAR
#define DP_SND_SOUND7_WIP2
#define DP_SND_STEREOWAV
#define DP_SND_OGGVORBIS
#define DP_SOLIDCORPSE
#define DP_SPRITE32
#define DP_SV_BOTCLIENT
#define DP_SV_CLIENTCAMERA /* Works like svc_setview except also handles pvs. */
#define DP_SV_CLIENTCOLORS /* Provided only for compatibility with DP. */
#define DP_SV_CLIENTNAME /* Provided only for compatibility with DP. */
#define DP_SV_DRAWONLYTOCLIENT
#define DP_SV_DROPCLIENT /* Equivelent to quakeworld's stuffcmd(self,"disconnect\n"); hack */
#define DP_SV_EFFECT
#define DP_SV_EXTERIORMODELFORCLIENT
#define DP_SV_NODRAWTOCLIENT
#define DP_SV_PLAYERPHYSICS /* Allows reworking parts of NQ player physics. USE AT OWN RISK - this necessitates NQ physics and is thus guarenteed to break prediction. */
#define DP_SV_POINTSOUND
#define DP_SV_PRECACHEANYTIME /* Specifies that the various precache builtins can be called at any time. WARNING: precaches are sent reliably while sound events, modelindexes, and particle events are not. This can mean sounds and particles might not work the first time around, or models may take a while to appear (after the reliables are received and the model is loaded from disk). Always attempt to precache a little in advance in order to reduce these issues (preferably at the start of the map...) */
#define DP_SV_PRINT /* Says that the print builtin can be used from nqssqc (as well as just csqc), bypassing the developer cvar issues. */
#define DP_SV_SETCOLOR
#define DP_SV_SPAWNFUNC_PREFIX
#define DP_SV_WRITEPICTURE
#define DP_SV_WRITEUNTERMINATEDSTRING
#define DP_TE_BLOOD
#define DP_TE_CUSTOMFLASH
#define DP_TE_EXPLOSIONRGB
#define DP_TE_PARTICLECUBE
#define DP_TE_PARTICLERAIN
#define DP_TE_PARTICLESNOW
#define DP_TE_SMALLFLASH
#define DP_TE_SPARK
#define DP_TE_STANDARDEFFECTBUILTINS
#define DP_VIEWZOOM
#define EXT_BITSHIFT
#define EXT_DIMENSION_VISIBILITY
#define EXT_DIMENSION_PHYSICS
#define EXT_DIMENSION_GHOST
#define FRIK_FILE
#define FTE_CALLTIMEOFDAY /* Replication of mvdsv functionality (call calltimeofday to cause 'timeofday' to be called, with arguments that can be saved off to a global). Generally strftime is simpler to use. */
#define FTE_CSQC_ALTCONSOLES /* The engine tracks multiple consoles. These may or may not be directly visible to the user. */
#define FTE_CSQC_BASEFRAME /* Specifies that .basebone, .baseframe2, .baselerpfrac, baseframe1time, etc exist in csqc. These fields affect all bones in the entity's model with a lower index than the .basebone field, allowing you to give separate control to the legs of a skeletal model, without affecting the torso animations. */
#define FTE_CSQC_HALFLIFE_MODELS
#define FTE_CSQC_SERVERBROWSER /* Provides builtins to query the engine's serverbrowser servers list from ssqc. Note that these builtins are always available in menuqc. */
#define FTE_CSQC_SKELETONOBJECTS /* Provides container objects for skeletal bone data, which can be modified on a per bone basis if needed. This allows you to dynamically generate animations (or just blend them with greater customisation) instead of being limited to a single animation or two. */
#define FTE_CSQC_RAWIMAGES /* Provides raw rgba image access to csqc. With this, the csprogs can read textures into qc-accessible memory, modify it, and then upload it to the renderer. */
#define FTE_CSQC_RENDERTARGETS /* VF_RT_DESTCOLOUR exists and can be used to redirect any rendering to a texture instead of the screen. */
#define FTE_CSQC_REVERB /* Specifies that the mod can create custom reverb effects. Whether they will actually be used or not depends upon the sound driver. */
#define FTE_CSQC_WINDOWCAPTION /* Provides csqc with the ability to change the window caption as displayed when running windowed or in the task bar when switched out. */
#define FTE_ENT_SKIN_CONTENTS /* self.skin = CONTENTS_WATER; makes a brush entity into water. use -16 for a ladder. */
#define FTE_ENT_UNIQUESPAWNID
#define FTE_EXTENDEDTEXTCODES
#define FTE_FORCESHADER /* Allows csqc to override shaders on models with an explicitly named replacement. Also allows you to define shaders with a fallback if it does not exist on disk. */
#define FTE_FORCEINFOKEY /* Provides an easy way to change a user's userinfo from the server. */
#define FTE_GFX_QUAKE3SHADERS /* specifies that the engine has full support for vanilla quake3 shaders */
#define FTE_GFX_REMAPSHADER /* With the raw power of stuffcmds, the r_remapshader console command is exposed! This mystical command can be used to remap any shader to another. Remapped shaders that specify $diffuse etc in some form will inherit the textures implied by the surface. */
#define FTE_GFX_MODELEVENTS /* Provides a query for per-animation events in model files, including from progs/foo.mdl.events files. */
#define FTE_ISBACKBUFFERED /* Allows you to check if a client has too many reliable messages pending. */
#define FTE_MEMALLOC /* Allows dynamically allocating memory. Use pointers to access this memory. Memory will not be saved into saved games. */
#define FTE_MEDIA_AVI /* playfilm command supports avi files. */
#define FTE_MEDIA_CIN /* playfilm command supports q2 cin files. */
#define FTE_MEDIA_ROQ /* playfilm command supports q3 roq files. */
#define FTE_MULTIPROGS /* Multiple progs.dat files can be loaded inside the same qcvm. Insert new ones with addprogs inside the 'init' function, and use externvalue+externset to rewrite globals (and hook functions) to link them together. Note that the result is generally not very clean unless you carefully design for it beforehand. */
#define FTE_MULTITHREADED /* Faux multithreading, allowing multiple contexts to run in sequence. */
#define FTE_MVD_PLAYERSTATS /* In csqc, getplayerstat can be used to query any player's stats when playing back MVDs. isdemo will return 2 in this case. */
#define FTE_PART_SCRIPT /* Specifies that the r_particledesc cvar can be used to select a list of particle effects to load from particles/*.cfg, the format of which is documented elsewhere. */
#define FTE_PART_NAMESPACES /* Specifies that the engine can use foo.bar to load effect foo from particle description bar. When used via ssqc, this should cause the client to download whatever effects as needed. */
#define FTE_PART_NAMESPACE_EFFECTINFO /* Specifies that effectinfo.bar can load effects from effectinfo.txt for DP compatibility. */
#define FTE_QC_BASEFRAME /* Specifies that .basebone and .baseframe exist in ssqc. These fields affect all bones in the entity's model with a lower index than the .basebone field, allowing you to give separate control to the legs of a skeletal model, without affecting the torso animations, from ssqc. */
#define FTE_QC_FILE_BINARY /* Extends FRIK_FILE with binary read+write, as well as allowing seeking. Requires pointers. */
#define FTE_QC_CHANGELEVEL_HUB /* Adds an extra argument to changelevel which is carried over to the next map in the 'spawnspot' global. Maps will be saved+reloaded until the extra argument is omitted again, purging all saved maps. Saved games will contain a copy of each preserved map. parm1-parm64 globals can be used, giving more space to transfer more player data. */
#define FTE_QC_CHECKCOMMAND /* Provides a way to test if a console command exists, and whether its a command/alias/cvar. Does not say anything about the expected meanings of any arguments or values. */
#define FTE_QC_CHECKPVS
#define FTE_QC_CROSSPRODUCT
#define FTE_QC_CUSTOMSKINS /* The engine supports the use of q3 skins, as well as the use of such skin 'files' to specify rich top+bottom colours, qw skins, geomsets, or texture composition even on non-players.. */
#define FTE_QC_FS_SEARCH_SIZEMTIME
#define FTE_QC_HARDWARECURSORS /* setcursormode exists in both csqc+menuqc, and accepts additional arguments to specify a cursor image to use when this module has focus. If the image exceeds hardware limits (or hardware cursors are unsupported), it will be emulated using regular draws - this at least still avoids conflicting cursors as only one will ever be used, even if console+menu+csqc are all overlayed. */
#define FTE_QC_HASHTABLES /* Provides efficient string-based lookups. */
#define FTE_QC_INFOKEY /* QuakeWorld's infokey builtin works, and reports at least name+topcolor+bottomcolor+ping(in ms)+ip(unmasked, but not always ipv4)+team(aka bottomcolor in nq). Does not require actual localinfo/serverinfo/userinfo, but they're _highly_ recommended to any engines with csqc */
#define FTE_QC_INTCONV /* Provides string<>int conversions, including hex representations. */
#define FTE_QC_MATCHCLIENTNAME
#define FTE_QC_MULTICAST /* QuakeWorld's multicast builtin works along with MSG_MULTICAST, but also with unicast support. */
#define FTE_QC_PAUSED
#define FTE_QC_PERSISTENTTEMPSTRINGS /* Supersedes DP_QC_MULTIPLETEMPSTRINGS. Temp strings are garbage collected automatically, and do not expire while they're still in use. This makes strzone redundant. */
#define FTE_QC_RAGDOLL_WIP
#define FTE_QC_SENDPACKET /* Allows the use of out-of-band udp packets to/from other hosts. Includes the SV_ParseConnectionlessPacket event. */
#define FTE_QC_STUFFCMDFLAGS /* Variation on regular stuffcmd that gives control over how spectators/mvds should be treated. */
#define FTE_QC_TRACETRIGGER
#define FTE_QUAKE2_CLIENT /* This engine is able to act as a quake2 client */
#define FTE_QUAKE2_SERVER /* This engine is able to act as a quake2 server */
#define FTE_QUAKE3_CLIENT /* This engine is able to act as a quake3 client */
#define FTE_QUAKE3_SERVER /* This engine is able to act as a quake3 server */
#define FTE_SOLID_LADDER /* Allows a simple trigger to remove effects of gravity (solid 20). obsolete. will prolly be removed at some point as it is not networked properly. Use FTE_ENT_SKIN_CONTENTS */
#define FTE_SPLITSCREEN /* Client supports splitscreen, controlled via cl_splitscreen. Servers require allow_splitscreen 1 if splitscreen is to be used over the internet. Mods that use csqc will need to be aware for this to work properly. per-client networking may be problematic. */
#define FTE_SQL /* Provides sql* builtins which can be used for sql database access */
#define FTE_SQL_SQLITE /* SQL functionality is able to utilise sqlite databases */
#define FTE_STRINGS /* Extra builtins (and additional behaviour) to make string manipulation easier */
#define FTE_SV_POINTPARTICLES /* Specifies that particleeffectnum, pointparticles, and trailparticles exist in ssqc as well as csqc. particleeffectnum acts as a precache, allowing ssqc values to be networked up with csqc for use. Use in combination with FTE_PART_SCRIPT+FTE_PART_NAMESPACES to use custom effects. This extension is functionally identical to the DP version, but avoids any misplaced assumptions about the format of the client's particle descriptions. */
#define FTE_SV_REENTER
#define FTE_TE_STANDARDEFFECTBUILTINS /* Provides builtins to replace writebytes, with a QW compatible twist. */
#define FTE_TERRAIN_MAP /* This engine supports .hmp files, as well as terrain embedded within bsp files. */
#define FTE_RAW_MAP /* This engine supports directly loading .map files, as well as realtime editing of the various brushes. */
#define KRIMZON_SV_PARSECLIENTCOMMAND /* SSQC's SV_ParseClientCommand function is able to handle client 'cmd' commands. The tokenizing parts also work in csqc. */
#define NEH_CMD_PLAY2
#define NEH_RESTOREGAME
#define QSG_CVARSTRING
#define QW_ENGINE
#define QWE_MVD_RECORD /* You can use the easyrecord command to record MVD demos serverside. */
#define TEI_MD3_MODEL
#define TENEBRAE_GFX_DLIGHTS /* Allows ssqc to attach rtlights to entities with various special properties. */
#define ZQ_MOVETYPE_FLY /* MOVETYPE_FLY works on players. */
#define ZQ_MOVETYPE_NOCLIP /* MOVETYPE_NOCLIP works on players. */
#define ZQ_MOVETYPE_NONE /* MOVETYPE_NONE works on players. */
#define ZQ_VWEP
#define ZQ_QC_STRINGS /* The strings-only subset of FRIK_FILE is supported. */

#ifdef _ACCESSORS
accessor strbuf : float;
accessor searchhandle : float;
accessor hashtable : float;
accessor infostring : string;
accessor filestream : float;
accessor filestream : float;
#else
#define strbuf float
#define searchhandle float
#define hashtable float
#define infostring string
#define filestream float
#endif

entity self;	/* The magic me */
void end_sys_globals;
void end_sys_fields;
float time;	/* The current local time. Increases while paused. */
void(float reqid, float responsecode, string resourcebody, int resourcebytes) URI_Get_Callback;	/* Called as an eventual result of the uri_get builtin. */
void(string cmdtext) GameCommand;
string(string uri, string method, string postdata, __in string requestheaders, __inout string responseheaders) Cef_GeneratePage;	/* Provides an entrypoint to generate pages for the CEF plugin from within QC. Headers are 
-separated key/value pairs (use tokenizebyseparator). */
void() m_init;
void() m_shutdown;
void(vector screensize) m_draw;	/* Provides the menuqc with a chance to draw. Will be called even if the menu does not have focus, so be sure to avoid that. COMPAT: screensize is not provided in DP. */
void(vector screensize, float opaque) m_drawloading;	/* Additional drawing function to draw loading screens. If opaque is set, then this function must ensure that the entire screen is overdrawn (even if just by a black drawfill). */
float(float evtype, float scanx, float chary, float devid) Menu_InputEvent;	/* If present, this is called instead of m_keydown and m_keyup
Called whenever a key is pressed, the mouse is moved, etc. evtype will be one of the IE_* constants. The other arguments vary depending on the evtype. Key presses are not guarenteed to have both scan and unichar values set at the same time. */
void(float scan, float chr) m_keydown;
void(float scan, float chr) m_keyup;
void(float wantmode) m_toggle;
float(string cmd) m_consolecommand;
var vector drawfontscale = '1 1 0';	/* Specifies a scaler for all text rendering. There are other ways to implement this. */
float drawfont;	/* Allows you to choose exactly which font is to be used to draw text. Fonts can be registered/allocated with the loadfont builtin. */
const float FONT_DEFAULT = 0;
const float TRUE = 1;
const float FALSE = 0;	/* File not found... */
const float M_PI = 3.14159;
const float RESTYPE_MODEL = 0;	/* RESTYPE_* constants are used as arguments with the resourcestatus builtin. */
const float RESTYPE_SOUND = 1;	/* precache_sound */
const float RESTYPE_PARTICLE = 2;	/* particleeffectnum */
const float RESTYPE_PIC = 3;	/* precache_pic. Status results are an amalgomation of the textures used by the named shader. */
const float RESTYPE_SKIN = 4;	/* setcustomskin */
const float RESTYPE_TEXTURE = 5;	/* Individual textures within shaders. These are not directly usable, but may be named as part of a skin file, or a shader. */
const float RESSTATE_NOTKNOWN = 0;	/* RESSTATE_* constants are return values from the resourcestatus builtin. The engine doesn't know about the resource if it is in this state. This means you will need to precache it. Attempting to use it anyway may result in warnings, errors, or silently succeed, depending on engine version and resource type. */
const float RESSTATE_NOTLOADED = 1;	/* The resource was precached, but has been flushed and there has not been an attempt to reload it. If you use the resource normally, chances are it'll be loaded but at the cost of a stall. */
const float RESSTATE_LOADING = 2;	/* Resources in this this state are queued for loading, and will be loaded at the engine's convienience. If you attempt to query the resource now, the engine will stall until the result is available. sounds in this state may be delayed, while models/pics/shaders may be invisible. */
const float RESSTATE_FAILED = 3;	/* Resources in this state are unusable/could not be loaded. You will get placeholders or dummy results. Queries will not stall the engine. The engine may display placeholder content. */
const float RESSTATE_LOADED = 4;	/* Resources in this state are finally usable, everything will work okay. Hurrah. Queries will not stall the engine. */
hashtable gamestate;	/* Special hash table index for hash_add and hash_get. Entries in this table will persist over map changes (and doesn't need to be created/deleted). */
const float HASH_REPLACE = 256;	/* Used with hash_add. Attempts to remove the old value instead of adding two values for a single key. */
const float HASH_ADD = 512;	/* Used with hash_add. The new entry will be inserted in addition to the existing entry. */
const float VF_MIN = 1;	/* The top-left of the 3d viewport in screenspace. The VF_ values are used via the setviewprop/getviewprop builtins. */
const float VF_MIN_X = 2;
const float VF_MIN_Y = 3;
const float VF_SIZE = 4;	/* The width+height of the 3d viewport in screenspace. */
const float VF_SIZE_X = 5;
const float VF_SIZE_Y = 6;
const float VF_VIEWPORT = 7;	/* vector+vector. Two argument shortcut for VF_MIN and VF_SIZE */
const float VF_FOV = 8;	/* sets both fovx and fovy. consider using afov instead. */
const float VF_FOVX = 9;	/* horizontal field of view. does not consider aspect at all. */
const float VF_FOVY = 10;	/* vertical field of view. does not consider aspect at all. */
const float VF_ORIGIN = 11;	/* The origin of the view. Not of the player. */
const float VF_ORIGIN_X = 12;
const float VF_ORIGIN_Y = 13;
const float VF_ORIGIN_Z = 14;
const float VF_ANGLES = 15;	/* The angles the view will be drawn at. Not the angle the client reports to the server. */
const float VF_ANGLES_X = 16;
const float VF_ANGLES_Y = 17;
const float VF_ANGLES_Z = 18;
const float VF_MINDIST = 23;	/* The distance of the near clip plane from the view position. Should generally not be <=0, as this would introduce NANs. */
const float VF_MAXDIST = 24;	/* The distance of the far clip plane from the view position. If 0, will be considered infinite. */
const float VF_PERSPECTIVE = 200;	/* 1: regular rendering. Fov specifies the angle. 0: isometric-style. Fov specifies the number of Quake Units each side of the viewport, and mindist restrictions are removed, pvs culling should be disabled. */
const float VF_AFOV = 203;	/* Aproximate fov. Matches the 'fov' cvar. The engine handles the aspect ratio for you. */
const float VF_SCREENVSIZE = 204;	/* Provides a reliable way to retrieve the current virtual screen size (even if the screen is automatically scaled to retain aspect). */
const float VF_SCREENPSIZE = 205;	/* Provides a reliable way to retrieve the current physical screen size (cvars need vid_restart for them to take effect). */
const float VF_RT_DESTCOLOUR = 212;	/* The texture name to write colour info into, this includes both 3d and 2d drawing.
Additional arguments are: format (IMGFMT_*), sizexy.
Written to by both 3d and 2d rendering.
Note that any rendertarget textures may be destroyed on video mode changes or so. Shaders can name render targets by prefixing texture names with '$rt:', or $sourcecolour. */
const float VF_RT_DESTCOLOUR1 = 213;	/* Like VF_RT_DESTCOLOUR, for multiple render targets. */
const float VF_RT_DESTCOLOUR2 = 214;	/* Like VF_RT_DESTCOLOUR, for multiple render targets. */
const float VF_RT_DESTCOLOUR3 = 215;	/* Like VF_RT_DESTCOLOUR, for multiple render targets. */
const float VF_RT_SOURCECOLOUR = 209;	/* The texture name to use with shaders that specify a $sourcecolour map. */
const float VF_RT_DEPTH = 210;	/* The texture name to use as a depth buffer. Also used for shaders that specify $sourcedepth. 1-based. Additional arguments are: format (IMGFMT_D*), sizexy. */
const float VF_RT_RIPPLE = 211;	/* The texture name to use as a ripplemap (target for shaders with 'sort ripple'). Also used for shaders that specify $ripplemap. 1-based. Additional arguments are: format, sizexy. */
const float VF_ENVMAP = 220;	/* The cubemap name to use as a fallback for $reflectcube, if a shader was unable to load one. Note that this doesn't automatically change shader permutations or anything. */
const float VF_USERDATA = 221;	/* Pointer (and byte size) to an array of vec4s. This data is then globally visible to all glsl via the w_user uniform. */
const float VF_PROJECTIONOFFSET = 224;	/* vec2 horizontal+vertical offset for the projection matrix, for weird off-centre rendering. */
const float IMGFMT_R8G8B8A8 = 1;	/* Typical 32bit rgba pixel format. */
const float IMGFMT_R16G16B16A16F = 2;	/* Half-Float pixel format. Requires gl3 support. */
const float IMGFMT_R32G32B32A32F = 3;	/* Regular Float pixel format. Requires gl3 support. */
const float IMGFMT_D16 = 4;	/* 16-bit depth pixel format. Must not be used with VF_RT_DESTCOLOUR*. */
const float IMGFMT_D24 = 5;	/* 24-bit depth pixel format. Must not be used with VF_RT_DESTCOLOUR*. */
const float IMGFMT_D32 = 6;	/* 32-bit depth pixel format. Must not be used with VF_RT_DESTCOLOUR*. */
const float IMGFMT_R8 = 7;	/* Single channel red-only 8bit pixel format. */
const float IMGFMT_R16F = 8;	/* Single channel red-only Half-Float pixel format. Requires gl3 support. */
const float IMGFMT_R32F = 9;	/* Single channel red-only Float pixel format. Requires gl3 support. */
const float IMGFMT_A2B10G10R10 = 10;	/* Packed 32-bit packed 10-bit colour pixel format. Requires gl3 support. */
const float IMGFMT_R5G6B5 = 11;	/* Packed 16-bit colour pixel format. */
const float IMGFMT_R4G4B4A4 = 12;	/* Packed 16-bit colour pixel format, with alpha */
const float IMGFMT_R8G8 = 13;	/* 16-bit two-channel pixel format. */
const float IMGFMT_R32G32B32F = 14;	/* A pixel format that matches QC's vector type. */
const float RF_DEPTHHACK = 4;	/* Hacks the depth values such that the entity uses depth values as if it were closer to the screen. This is useful when combined with viewmodels to avoid weapons poking in to walls. */
const float RF_ADDITIVE = 8;	/* Shaders from this entity will temporarily be hacked to use an additive blend mode instead of their normal blend mode. */
const float IE_KEYDOWN = 0;	/* Specifies that a key was pressed. Second argument is the scan code. Third argument is the unicode (printable) char value. Fourth argument denotes which keyboard(or mouse, if its a mouse 'scan' key) the event came from. Note that some systems may completely separate scan codes and unicode values, with a 0 value for the unspecified argument. */
const float IE_KEYUP = 1;	/* Specifies that a key was released. Arguments are the same as IE_KEYDOWN. On some systems, this may be fired instantly after IE_KEYDOWN was fired. */
const float IE_MOUSEDELTA = 2;	/* Specifies that a mouse was moved (touch screens and tablets typically give IE_MOUSEABS events instead, use in_windowed_mouse 0 to test code to cope with either). Second argument is the X displacement, third argument is the Y displacement. Fourth argument is which mouse or touch event triggered the event. */
const float IE_MOUSEABS = 3;	/* Specifies that a mouse cursor or touch event was moved to a specific location relative to the virtual screen space. Second argument is the new X position, third argument is the new Y position. Fourth argument is which mouse or touch event triggered the event. */
const float IE_ACCELEROMETER = 4;
const float IE_FOCUS = 5;	/* Specifies that input focus was given. parama says mouse focus, paramb says keyboard focus. If either are -1, then it is unchanged. */
const float IE_JOYAXIS = 6;	/* Specifies that what value a joystick/controller axis currently specifies. x=axis, y=value. Will be called multiple times, once for each axis of each active controller. */
const float IE_GYROSCOPE = 7;
const float FILE_READ = 0;	/* The file may be read via fgets to read a single line at a time. */
const float FILE_APPEND = 1;	/* Like FILE_WRITE, but writing starts at the end of the file. */
const float FILE_WRITE = 2;	/* fputs will be used to write to the file. */
const float SLIST_HOSTCACHEVIEWCOUNT = 0;
const float SLIST_HOSTCACHETOTALCOUNT = 1;
const float SLIST_MASTERQUERYCOUNT = 2;
const float SLIST_MASTERREPLYCOUNT = 3;
const float SLIST_SERVERQUERYCOUNT = 4;
const float SLIST_SERVERREPLYCOUNT = 5;
const float SLIST_SORTFIELD = 6;
const float SLIST_SORTDESCENDING = 7;
const float SLIST_TEST_CONTAINS = 0;
const float SLIST_TEST_NOTCONTAIN = 1;
const float SLIST_TEST_LESSEQUAL = 2;
const float SLIST_TEST_LESS = 3;
const float SLIST_TEST_EQUAL = 4;
const float SLIST_TEST_GREATER = 5;
const float SLIST_TEST_GREATEREQUAL = 6;
const float SLIST_TEST_NOTEQUAL = 7;
const float SLIST_TEST_STARTSWITH = 8;
const float SLIST_TEST_NOTSTARTSWITH = 9;
float(string ext) checkextension = #1; /*
		Checks if the named extension is supported by the running engine. */

void(string err,...) error = #2; /*
		Fatal error that will trigger a crash-to-console that users will actually notice. */

void(string err,...) objerror = #3; /*
		For some reason this has been redefined as non-fatal, and as it won't force the user to look at the console it'll generally be ignored completely so really what's the point? Other than as a convoluted way to remove(self) that is. */

void(string text,...) print = #4; /* Part of DP_SV_PRINT
		Hello, world. Shoves junk on the console. Hopefully people will bother to read it, maybe. */

void(string text,...) bprint = #5;
void(float clientnum, string text,...) msprint = #6;
void(string text,...) cprint = #7; /*
		Tries to show the given message in the centre of the screen, assuming that its not obscured by menus. Oh hey look, you're calling it in menuqc! */

vector(vector) normalize = #8;
float(vector) vlen = #9;
float(vector) vectoyaw = #10;
vector(vector) vectoangles = #11;
float() random = #12;
void(string,...) localcmd = #13;
float(string name) cvar = #14;
void(string name, string value) cvar_set = #15;
void(string text) dprint = #16;
string(float) ftos = #17;
float(float) fabs = #18;
string(vector) vtos = #19;
string(entity) etos = #20; /* Part of DP_QC_ETOS*/
float(string) stof = #21; /* Part of FRIK_FILE, FTE_QC_INFOKEY, FTE_STRINGS, QW_ENGINE, ZQ_QC_STRINGS*/
entity() spawn = #22;
void(entity) remove = #23;
entity(entity start, .string field, string match) find = #24;
entity(entity start, .__variant field, __variant match) findfloat = #25; /* Part of DP_QC_FINDFLOAT*/
entity(.string field, string match) findchain = #26; /* Part of DP_QC_FINDCHAIN*/
entity(.__variant field, __variant match) findchainfloat = #27; /* Part of DP_QC_FINDCHAINFLOAT*/
string(string file) precache_file = #28; /*
		Attempts to download the named file from the current server, if it isn't found locally. Not very useful as menuqc is normally meant to work before joining servers too. */

string(string sample) precache_sound = #29;
void() coredump = #30; /*
		Takes a dump, writing the qcvm's state to disk. There are normally easier ways to debug, but I suppose this one still beats print spam. */

void() traceon = #31; /*
		Enables single-stepping. Its generally easier to just set a breakpoint. */

void() traceoff = #32; /*
		Disables single-stepping. Which sucks if you started said singlestepping outside of qc. */

void(entity) eprint = #33;
float(float) rint = #34;
float(float) floor = #35;
float(float) ceil = #36;
entity(entity) nextent = #37;
float(float) sin = #38; /* Part of DP_QC_SINCOSSQRTPOW*/
float(float) cos = #39; /* Part of DP_QC_SINCOSSQRTPOW*/
float(float) sqrt = #40; /* Part of DP_QC_SINCOSSQRTPOW*/
vector() randomvector = #41;
float(string name, string value, float flags) registercvar = #42; /* Part of DP_REGISTERCVAR
		Creates the cvar if it didn't already exist. This presents issues for setting those cvars via startup configs of course, and autocvars are easier but I suppose they don't get any flags (which are ignored anyway, of course). */

float(float,...) min = #43; /* Part of DP_QC_MINMAXBOUND*/
float(float,...) max = #44; /* Part of DP_QC_MINMAXBOUND*/
float(float min,float value,float max) bound = #45; /* Part of DP_QC_MINMAXBOUND*/
float(float,float) pow = #46; /* Part of DP_QC_SINCOSSQRTPOW*/
void(entity src, entity dst) copyentity = #47; /* Part of DP_QC_COPYENTITY
		Copies all entity fields from one entity into another (forgetting any that were previously set on the destination). */

filestream(string filename, float mode) fopen = #48; /* Part of FRIK_FILE*/
void(filestream fhandle) fclose = #49; /* Part of FRIK_FILE*/
string(filestream fhandle) fgets = #50; /* Part of FRIK_FILE*/
void(filestream fhandle, string s) fputs = #51; /* Part of FRIK_FILE*/
float(string) strlen = #52; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
string(string, optional string, optional string, optional string, optional string, optional string, optional string, optional string) strcat = #53; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
string(string s, float start, float length) substring = #54; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
vector(string) stov = #55; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
string(string) strzone = #56; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS
		Exists in FTE for compat only, no different from strcat. */

void(string) strunzone = #57; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS
		Exists in FTE for compat only, does nothing. */

float(string) tokenize = #58; /* Part of KRIMZON_SV_PARSECLIENTCOMMAND
		Splits up the given string into its different components (what constitutes a token separator is not well defined and has been hacked about with over the years so have fun with that), returning the number of tokens that were found. Call argv(0 through ret-1) to retrieve each individual token. Take care to not use this recursively. */

string(float) argv = #59; /* Part of KRIMZON_SV_PARSECLIENTCOMMAND
		Returns one of the tokens found via tokenize (and equivelent builtins). */

float() isserver = #60; /*
		Returns true if the local engine is running a server, and thus cvars and localcmds are shared with said server. */

float() clientcount = #61; /*
		Returns the maximum number of players on the server. Useless if its a remote server, so its a kinda useless builtin really. */

float() clientstate = #62; /*
		Tells you whether the client is actually connected to anything. 0 for a dedicated server (but dedicated servers don't normally run menuqc anyway), 2 if connecting or connected to a server (but not necessarily spawned+active), 1 for sitting around idle without trying to connect to anything yet. */

void(string map) changelevel = #64; /*
		Not really any different from a localcmd, but with proper string escapes. */

void(string sample, optional float channel, optional float volume) localsound = #65; /*
		Plays a sound, locally. precaching is optional, but recommended. */

vector() getmousepos = #66; /*
		Obsolete. Return values depend upon the current cursor mode. Implement Menu_InputEvent instead, so you can handle deltas as-is or absolutes if that's all the OS can provide. */

float(optional float timetype) gettime = #67;
void(string s) loadfromdata = #68; /*
		Reads a set of entities from the given string. This string should have the same format as a .ent file or a saved game. Entities will be spawned as required. If you need to see the entities that were created, you should use parseentitydata instead. */

void(string s) loadfromfile = #69; /*
		Reads a set of entities from the named file. This file should have the same format as a .ent file or a saved game. Entities will be spawned as required. If you need to see the entities that were created, you should use parseentitydata instead. */

float(float val, float m) mod = #70;
string(string name) cvar_string = #71; /* Part of DP_QC_CVAR_STRING
		Returns the value of a cvar, as a string. */

void() crash = #72; /*
		Demonstrates that no program is bug free. */

void() stackdump = #73; /*
		Prints out the QC's stack, for console-based error reports. */

searchhandle(string pattern, float caseinsensitive, float quiet) search_begin = #74; /* Part of DP_QC_FS_SEARCH*/
void(searchhandle handle) search_end = #75; /* Part of DP_QC_FS_SEARCH*/
float(searchhandle handle) search_getsize = #76; /* Part of DP_QC_FS_SEARCH*/
string(searchhandle handle, float num) search_getfilename = #77; /* Part of DP_QC_FS_SEARCH*/
float(entity) etof = #79;
entity(float) ftoe = #80;
float(string) validstring = #81; /*
		Returns true if str isn't null. In case 'if [not](str)' was configured to test for empty instead of null. */

float(string str) altstr_count = #82; /*
		Reports how many single-quotes there were in the string, divided by 2. */

string(string str) altstr_prepare = #83; /*
		Adds markup to escape only single-quotes. Does not add any. */

string(string str, float num) altstr_get = #84; /*
		Gets the Nth single-quoted token in the input. */

string(string str, float num, string setval) altstr_set = #85; /*
		Changes the Nth single-quoted token. The setval argument must not contain any single-quotes (use altstr_prepare to ensure this). */

entity(entity start, .float field, float match) findflags = #87; /* Part of DP_QC_FINDFLAGS*/
entity(.float field, float match) findchainflags = #88; /* Part of DP_QC_FINDCHAINFLAGS*/
void(entity ent, string mname) setmodel = #90; /*
		Menuqc-specific version. */

void(string mname) precache_model = #91; /*
		Menuqc-specific version. */

void(entity ent, vector neworg) setorigin = #92; /*
		Menuqc-specific version. */

float(float v, optional float base) logarithm = #0:logarithm; /*
		Determines the logarithm of the input value according to the specified base. This can be used to calculate how much something was shifted by. */

float(__variant funcref) checkbuiltin = #0:checkbuiltin; /*
		Checks to see if the specified builtin is supported/mapped. This is intended as a way to check for #0 functions, allowing for simple single-builtin functions. Warning, if two different engines map different builtins to the same number, then this function will not tell you which will be called, only that it won't crash (the exception being #0, which are remapped as available). */

int(filestream fhandle, void *ptr, int size) fread = #0:fread; /* Part of FTE_QC_FILE_BINARY
		Reads binary data out of the file. Returns truncated lengths if the read exceeds the length of the file. */

int(filestream fhandle, void *ptr, int size) fwrite = #0:fwrite; /* Part of FTE_QC_FILE_BINARY
		Writes binary data out of the file. */

#define ftell fseek //c compat
int(filestream fhandle, optional int newoffset) fseek = #0:fseek; /* Part of FTE_QC_FILE_BINARY
		Changes the current position of the file, if specified. Returns prior position, in bytes. */

int(filestream fhandle, optional int newsize) fsize = #0:fsize; /* Part of FTE_QC_FILE_BINARY
		Reports the total size of the file, in bytes. Can also be used to truncate/extend the file */

void(optional __variant ret) abort = #211; /* Part of FTE_MULTITHREADED
		QC execution is aborted. Parent QC functions on the stack will be skipped, effectively this forces all QC functions to 'return ret' until execution returns to the engine. If ret is ommited, it is assumed to be 0. */

float(string s1, string sub, optional float startidx) strstrofs = #221; /* Part of FTE_STRINGS
		Returns the 0-based offset of sub within the s1 string, or -1 if sub is not in s1.
		If startidx is set, this builtin will ignore matches before that 0-based offset. */

float(string str, float index) str2chr = #222; /* Part of FTE_STRINGS
		Retrieves the character value at offset 'index'. */

string(float chr, ...) chr2str = #223; /* Part of FTE_STRINGS
		The input floats are considered character values, and are concatenated. */

string(float ccase, float redalpha, float redchars, string str, ...) strconv = #224; /* Part of FTE_STRINGS
		Converts quake chars in the input string amongst different representations.
		ccase specifies the new case for letters.
		 0: not changed.
		 1: forced to lower case.
		 2: forced to upper case.
		redalpha and redchars switch between colour ranges.
		 0: no change.
		 1: Forced white.
		 2: Forced red.
		 3: Forced gold(low) (numbers only).
		 4: Forced gold (high) (numbers only).
		 5+6: Forced to white and red alternately.
		You should not use this builtin in combination with UTF-8. */

string(float pad, string str1, ...) strpad = #225; /* Part of FTE_STRINGS
		Pads the string with spaces, to ensure its a specific length (so long as a fixed-width font is used, anyway). If pad is negative, the spaces are added on the left. If positive the padding is on the right. */

string(infostring old, string key, string value) infoadd = #226; /* Part of FTE_STRINGS
		Returns a new tempstring infostring with the named value changed (or added if it was previously unspecified). Key and value may not contain the \ character. */

string(infostring info, string key) infoget = #227; /* Part of FTE_STRINGS
		Reads a named value from an infostring. The returned value is a tempstring */

#define strcmp strncmp
float(string s1, string s2, optional float len, optional float s1ofs, optional float s2ofs) strncmp = #228; /* Part of FTE_STRINGS
		Compares up to 'len' chars in the two strings. s1ofs allows you to treat s2 as a substring to compare against, or should be 0.
		Returns 0 if the two strings are equal, a negative value if s1 appears numerically lower, and positive if s1 appears numerically higher. */

float(string s1, string s2) strcasecmp = #229; /* Part of FTE_STRINGS
		Compares the two strings without case sensitivity.
		Returns 0 if they are equal. The sign of the return value may be significant, but should not be depended upon. */

float(string s1, string s2, float len, optional float s1ofs, optional float s2ofs) strncasecmp = #230; /* Part of FTE_STRINGS
		Compares up to 'len' chars in the two strings without case sensitivity. s1ofs allows you to treat s2 as a substring to compare against, or should be 0.
		Returns 0 if they are equal. The sign of the return value may be significant, but should not be depended upon. */

string(string s) strtrim = #0:strtrim; /*
		Trims the whitespace from the start+end of the string. */

float(string shadername, optional string defaultshader, ...) shaderforname = #238; /* Part of FTE_FORCESHADER
		Caches the named shader and returns a handle to it.
		If the shader could not be loaded from disk (missing file or ruleset_allow_shaders 0), it will be created from the 'defaultshader' string if specified, or a 'skin shader' default will be used.
		defaultshader if not empty should include the outer {} that you would ordinarily find in a shader. */

void(string destaddress, string content) sendpacket = #242; /* Part of FTE_QC_SENDPACKET
		Sends a UDP packet to the specified destination. Note that the payload will be prefixed with four 255 bytes as a sort of security feature. */

int(float) ftoi = #0:ftoi; /* Part of FTE_QC_INTCONV
		Converts the given float into a true integer without depending on extended qcvm instructions. */

float(int) itof = #0:itof; /* Part of FTE_QC_INTCONV
		Converts the given true integer into a float without depending on extended qcvm instructions. */

#define dotproduct(v1,v2) ((vector)(v1)*(vector)(v2))
vector(vector v1, vector v2) crossproduct = #0:crossproduct; /* Part of FTE_QC_CROSSPRODUCT
		Small helper function to calculate the crossproduct of two vectors. */

hashtable(float tabsize, optional float defaulttype) hash_createtab = #287; /* Part of FTE_QC_HASHTABLES
		Creates a hash table object with at least 'tabsize' slots. hash table with index 0 is a game-persistant table and will NEVER be returned by this builtin (except as an error return). */

void(hashtable table) hash_destroytab = #288; /* Part of FTE_QC_HASHTABLES
		Destroys a hash table object. */

void(hashtable table, string name, __variant value, optional float typeandflags) hash_add = #289; /* Part of FTE_QC_HASHTABLES
		Adds the given key with the given value to the table.
		If flags&HASH_REPLACE, the old value will be removed, if not set then multiple values may be added for a single key, they won't overwrite.
		The type argument describes how the value should be stored and saved to files. While you can claim that all variables are just vectors, being more precise can result in less issues with tempstrings or saved games. */

__variant(hashtable table, string name, optional __variant deflt, optional float requiretype, optional float index) hash_get = #290; /* Part of FTE_QC_HASHTABLES
		looks up the specified key name in the hash table. returns deflt if key was not found. If stringsonly=1, the return value will be in the form of a tempstring, otherwise it'll be the original value argument exactly as it was. If requiretype is specified, then values not of the specified type will be ignored. Hurrah for multiple types with the same name. */

__variant(hashtable table, string name) hash_delete = #291; /* Part of FTE_QC_HASHTABLES
		removes the named key. returns the value of the object that was destroyed, or 0 on error. */

string(hashtable table, float idx) hash_getkey = #292; /* Part of FTE_QC_HASHTABLES
		gets some random key name. add+delete can change return values of this, so don't blindly increment the key index if you're removing all. */

float(string name) checkcommand = #294; /* Part of FTE_QC_CHECKCOMMAND
		Checks to see if the supplied name is a valid command, cvar, or alias. Returns 0 if it does not exist. */

string(string s) argescape = #295; /*
		Marks up a string so that it can be reliably tokenized as a single argument later. */

void() clearscene = #300; /*
		Forgets all rentities, polygons, and temporary dlights. Resets all view properties to their default values. */

void(entity ent) addentity = #302; /*
		Copies the entity fields into a new rentity for later rendering via addscene. */

#define setviewprop setproperty
float(float property, ...) setproperty = #303; /*
		Allows you to override default view properties like viewport, fov, and whether the engine hud will be drawn. Different VF_ values have slightly different arguments, some are vectors, some floats. */

void() renderscene = #304; /*
		Draws all entities, polygons, and particles on the rentity list (which were added via addentities or addentity), using the various view properties set via setproperty. There is no ordering dependancy.
		The scene must generally be cleared again before more entities are added, as entities will persist even over to the next frame.
		You may call this builtin multiple times per frame, but should only be called from CSQC_UpdateView. */

void(string texturename, optional float flags, optional float is2d) R_BeginPolygon = #306; /*
		Specifies the shader to use for the following polygons, along with optional flags.
		If is2d, the polygon will be drawn as soon as the EndPolygon call is made, rather than waiting for renderscene. This allows complex 2d effects. */

void(vector org, vector texcoords, vector rgb, float alpha) R_PolygonVertex = #307; /*
		Specifies a polygon vertex with its various properties. */

void() R_EndPolygon = #308; /*
		Ends the current polygon. At least 3 verticies must have been specified. You do not need to call beginpolygon again if you wish to draw another polygon with the same shader. */

#define getviewprop getproperty
__variant(float property) getproperty = #309; /*
		Retrieve a currently-set (typically view) property, allowing you to read the current viewport or other things. Due to cheat protection, certain values may be unretrievable. */

float(vector pos, vector size, float alignflags, string text) drawtextfield = #0:drawtextfield; /*
		Draws a multi-line block of text, including word wrapping and alignment. alignflags bits are RTLB, typically 3. Returns the total number of lines. */

void(string imagename, int width, int height, void *pixeldata, optional int datasize, optional int format) r_uploadimage = #0:r_uploadimage; /* Part of FTE_CSQC_RAWIMAGES
		Updates a texture with the specified rgba data (uploading it to the gpu). Will be created if needed. If datasize is specified then the image is decoded (eg .ktx or .dds data) instead of being raw R8G8B8A data. You'll typically want shaderforname to also generate a shader to use the texture. */

int*(string filename, __out int width, __out int height) r_readimage = #0:r_readimage; /* Part of FTE_CSQC_RAWIMAGES
		Reads and decodes an image from disk, providing raw R8G8B8A8 pixel data. Should not be used for dds or ktx etc formats. Returns __NULL__ if the image could not be read for any reason. Use memfree to free the data once you're done with it. */

void(vector pivot, vector mins, vector maxs, string pic, vector rgb, float alpha, float angle) drawrotpic = #0:drawrotpic; /*
		Draws an image rotating at the pivot. To rotate in the center, use mins+maxs of half the size with mins negated. Angle is in degrees. */

void(vector pivot, vector mins, vector maxs, string pic, vector txmin, vector txsize, vector rgb, vector alphaandangles) drawrotsubpic = #0:drawrotsubpic; /*
		Overcomplicated draw function for over complicated people. Positions follow drawrotpic, while texture coords follow drawsubpic. Due to argument count limitations in builtins, the alpha value and angles are combined into separate fields of a vector (tip: use fteqcc's [alpha, angle] feature. */

string(float keynum) keynumtostring_csqc = #340; /*
		Returns a hunam-readable name for the given keycode, as a tempstring. */

float(string keyname) stringtokeynum_csqc = #341; /*
		Looks up the key name in the same way that the bind command would, returning the keycode for that key. */

string(float keynum) getkeybind = #342; /*
		Returns the current binding for the given key (returning only the command executed when no modifiers are pressed). */

void(float usecursor, optional string cursorimage, optional vector hotspot, optional float scale) setcursormode = #343; /*
		Pass TRUE if you want the engine to release the mouse cursor (absolute input events + touchscreen mode). Pass FALSE if you want the engine to grab the cursor (relative input events + standard looking). If the image name is specified, the engine will use that image for a cursor (use an empty string to clear it again), in a way that will not conflict with the console. Images specified this way will be hardware accelerated, if supported by the platform/port. */

float(float effective) getcursormode = #0:getcursormode; /*
		Reports the cursor mode this module previously attempted to use. If 'effective' is true, reports the cursor mode currently active (if was overriden by a different module which has precidence, for instance, or if there is only a touchscreen and no mouse). */

void(vector newpos) setmousepos = #0:setmousepos; /*
		Warps the mouse cursor to the given location. Should normally only be done following setcursormode(TRUE,...). The warp MAY be visible through *_InputEvent, but normally be seen as an IE_ABSMOUSE event anyway. Not all systems support cursor warping (or even cursors), so this is a hint only and you should not depend upon it. */

void(float seat, string keyname, string newvalue) setlocaluserinfo = #0:setlocaluserinfo; /*
		Change a userinfo key for the local player, equivelent to the setinfo console command. The server will normally forward the setting to other clients. */

string(float seat, string keyname) getlocaluserinfo = #0:getlocaluserinfo; /*
		Reads a local userinfo key for the active seat. This is not quite the same as getplayerkeyvalue, due to latency and possible serverside filtering. */

void(float seat, string keyname, void *outptr, int size) setlocaluserinfoblob = #0:setlocaluserinfoblob; /*
		Sets the userinfo key to a blob that may contain nulls etc. Keys with a leading underscore will be visible to only the server (for user-specific binary settings). */

int(float seat, string keyname, void *outptr, int maxsize) getlocaluserinfoblob = #0:getlocaluserinfoblob; /*
		Obtains a copy of the full data blob. Will write up to size bytes but return the full size. Does not null terminate (but memalloc(ret+1) will, if you want to cast the buffer to a string), and the blob may contain embedded nulls. Ignores all special keys, returning only what is actually there. */

float() isdemo = #349; /*
		Returns if the client is currently playing a demo or not. Returns 2 when playing an mvd (where other player's stats can be queried, or the pov can be changed freely). */

void(string cmdname) registercommand = #352; /*
		Register the given console command, for easy console use.
		Console commands that are later used will invoke CSQC_ConsoleCommand. */

float(entity ent) wasfreed = #353; /*
		Quickly check to see if the entity is currently free. This function is only valid during the two-second non-reuse window, after that it may give bad results. Try one second to make it more robust. */

float(string s) findfont = #356; /* Part of DP_GFX_FONTS
		Looks up a named font slot. Matches the actual font name as a last resort. */

float(string fontname, string fontmaps, string sizes, float slot, optional float fix_scale, optional float fix_voffset) loadfont = #357; /* Part of DP_GFX_FONTS
		too convoluted for me to even try to explain correct usage. Try drawfont = loadfont("", "cour", "16", -1, 0, 0); to switch to the courier font (optimised for 16 virtual pixels high) ('cour' requires mscorefonts installed in linux). Additionally you can add "outline=1" as an extra token in the sizes string, to have more readable outlined fonts. */

void(entity e, string skinfilename, optional string skindata) setcustomskin = #376; /* Part of FTE_QC_CUSTOMSKINS
		Sets an entity's skin overrides to a new skin object. Releases the entities old skin (refcounted). */

__variant*(int size) memalloc = #384; /* Part of FTE_MEMALLOC
		Allocate an arbitary block of memory */

void(__variant *ptr) memfree = #385; /* Part of FTE_MEMALLOC
		Frees a block of memory that was allocated with memfree */

void(__variant *dst, __variant *src, int size) memcpy = #386; /* Part of FTE_MEMALLOC
		Copys memory from one location to another */

void(__variant *dst, int val, int size) memfill8 = #387; /* Part of FTE_MEMALLOC
		Sets an entire block of memory to a specified value. Pretty much always 0. */

__variant(__variant *dst, float ofs) memgetval = #388; /*
		Looks up the 32bit value stored at a pointer-with-offset. */

void(__variant *dst, float ofs, __variant val) memsetval = #389; /*
		Changes the 32bit value stored at the specified pointer-with-offset. */

__variant*(__variant *base, float ofs) memptradd = #390; /*
		Perform some pointer maths. Woo. */

float(string s) memstrsize = #0:memstrsize; /*
		strlen, except ignores utf-8 */

string(string conname, string field, optional string newvalue) con_getset = #391; /* Part of FTE_CSQC_ALTCONSOLES
		Reads or sets a property from a console object. The old value is returned. Iterrate through consoles with the 'next' field. Valid properties: 	title, name, next, unseen, markup, forceutf8, close, clear, hidden, linecount */

void(string conname, string messagefmt, ...) con_printf = #392; /* Part of FTE_CSQC_ALTCONSOLES
		Prints onto a named console. */

void(string conname, vector pos, vector size, float fontsize) con_draw = #393; /* Part of FTE_CSQC_ALTCONSOLES
		Draws the named console. */

float(string conname, float inevtype, float parama, float paramb, float paramc) con_input = #394; /* Part of FTE_CSQC_ALTCONSOLES
		Forwards input events to the named console. Mouse updates should be absolute only. */

void(string newcaption) setwindowcaption = #0:setwindowcaption; /* Part of FTE_CSQC_WINDOWCAPTION
		Replaces the title of the game window, as seen when task switching or just running in windowed mode. */

float() cvars_haveunsaved = #0:cvars_haveunsaved; /*
		Returns true if any archived cvar has an unsaved value. */

float(entity e, float nowreadonly) entityprotection = #0:entityprotection; /*
		Changes the protection on the specified entity to protect it from further edits from QC. The return value is the previous setting. Note that this can be used to unprotect the world, but doing so long term is not advised as you will no longer be able to detect invalid entity references. Also, world is not networked, so results might not be seen by clients (or in other words, world.avelocity_y=64 is a bad idea). */

strbuf() buf_create = #440; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle) buf_del = #441; /* Part of DP_QC_STRINGBUFFERS*/
float(strbuf bufhandle) buf_getsize = #442; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle_from, float bufhandle_to) buf_copy = #443; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle, float sortprefixlen, float backward) buf_sort = #444; /* Part of DP_QC_STRINGBUFFERS*/
string(strbuf bufhandle, string glue) buf_implode = #445; /* Part of DP_QC_STRINGBUFFERS*/
string(strbuf bufhandle, float string_index) bufstr_get = #446; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle, float string_index, string str) bufstr_set = #447; /* Part of DP_QC_STRINGBUFFERS*/
float(strbuf bufhandle, string str, float ordered) bufstr_add = #448; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle, float string_index) bufstr_free = #449; /* Part of DP_QC_STRINGBUFFERS*/
float(string name) iscachedpic = #451;
string(string name, optional float trywad) precache_pic = #452;
float(vector position, float character, vector scale, vector rgb, float alpha, optional float flag) drawcharacter = #454;
float(vector position, string text, vector scale, vector rgb, float alpha, optional float flag) drawrawstring = #455;
float(vector position, string pic, vector size, vector rgb, float alpha, optional float flag) drawpic = #456;
float(vector position, vector size, vector rgb, float alpha, optional float flag) drawfill = #457;
void(float x, float y, float width, float height) drawsetcliparea = #458;
void(void) drawresetcliparea = #459;
vector(string picname) drawgetimagesize = #460;
void(float width, vector pos1, vector pos2) drawline = #466;
float(vector position, string text, vector scale, vector rgb, float alpha, float flag) drawstring = #467;
float(string text, float usecolours, optional vector fontsize) stringwidth = #468;
void(vector pos, vector sz, string pic, vector srcpos, vector srcsz, vector rgb, float alpha, float flag) drawsubpic = #469;
float(searchhandle handle, float num) search_getfilesize = #0:search_getfilesize; /* Part of FTE_QC_FS_SEARCH_SIZEMTIME
		Retrieves the size of one of the files that was found by the initial search. */

string(searchhandle handle, float num) search_getfilemtime = #0:search_getfilemtime; /* Part of FTE_QC_FS_SEARCH_SIZEMTIME
		Retrieves modification time of one of the files. */

float(float s) asin = #471; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float c) acos = #472; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float t) atan = #473; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float c, float s) atan2 = #474; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float a) tan = #475; /* Part of DP_QC_ASINACOSATANATAN2TAN
		Forgive me father, for I have a sunbed and I'm not afraid to use it. */

float(string s) strlennocol = #476; /* Part of DP_QC_STRINGCOLORFUNCTIONS
		Returns the number of characters in the string after any colour codes or other markup has been parsed. */

string(string s) strdecolorize = #477; /* Part of DP_QC_STRINGCOLORFUNCTIONS
		Flattens any markup/colours, removing them from the string. */

string(float uselocaltime, string format, ...) strftime = #478; /* Part of DP_QC_STRFTIME*/
float(string s, string separator1, ...) tokenizebyseparator = #479; /* Part of DP_QC_TOKENIZEBYSEPARATOR*/
string(string s) strtolower = #480; /* Part of DP_QC_STRING_CASE_FUNCTIONS*/
string(string s) strtoupper = #481; /* Part of DP_QC_STRING_CASE_FUNCTIONS*/
string(string s) cvar_defstring = #482; /* Part of DP_QC_CVAR_DEFSTRING*/
string(string search, string replace, string subject) strreplace = #484; /* Part of DP_QC_STRREPLACE*/
string(string search, string replace, string subject) strireplace = #485; /* Part of DP_QC_STRREPLACE*/
float(string name, optional string initialURI) gecko_create = #487; /* Part of DP_GECKO_SUPPORT
		Create a new 'browser tab' shader with the specified name that can then be drawn via drawpic (shader should not already exist - including from map/model textures or disk). In order to function correctly, this builtin depends upon external plugins being available. Use gecko_navigate to navigate it to a page of your choosing. */

void(string name) gecko_destroy = #488; /* Part of DP_GECKO_SUPPORT
		Destroy a shader. */

void(string name, string URI) gecko_navigate = #489; /* Part of DP_GECKO_SUPPORT
		Sends a command to the media decoder attached to the specified shader. In the case of a browser decoder, this changes the url that the browser displays. 'cmd:[un]focus' will tell the decoder that it has focus. */

float(string name, float key, float eventtype, optional float charcode) gecko_keyevent = #490; /* Part of DP_GECKO_SUPPORT
		Send a key event to a media decoder. This applies only to interactive decoders like browsers. */

void(string name, float x, float y) gecko_mousemove = #491; /* Part of DP_GECKO_SUPPORT
		Sets a media decoder shader's mouse position. Values should be 0-1. */

void(string name, float w, float h) gecko_resize = #492; /* Part of DP_GECKO_SUPPORT
		Request to resize a media decoder. */

vector(string name) gecko_get_texture_extent = #493; /* Part of DP_GECKO_SUPPORT
		Retrieves a media decoder current image pixel sizes. */

string(string shadname, string propname) gecko_getproperty = #0:gecko_getproperty; /*
		Queries the media decoder (especially browser ones) for decoder-specific properties. The cef plugin recognises url, title, status. */

float(float caseinsensitive, string s, ...) crc16 = #494; /* Part of DP_QC_CRC16*/
float(string name) cvar_type = #495; /* Part of DP_QC_CVAR_TYPE*/
float() numentityfields = #496; /* Part of DP_QC_ENTITYDATA
		Gives the number of named entity fields. Note that this is not the size of an entity, but rather just the number of unique names (ie: vectors use 4 names rather than 3). */

float(string fieldname) findentityfield = #0:findentityfield; /*
		Find a field index by name. */

typedef .__variant field_t;
field_t(float fieldnum) entityfieldref = #0:entityfieldref; /*
		Returns a field value that can be directly used to read entity fields. Be sure to validate the type with entityfieldtype before using. */

string(float fieldnum) entityfieldname = #497; /* Part of DP_QC_ENTITYDATA
		Retrieves the name of the given entity field. */

float(float fieldnum) entityfieldtype = #498; /* Part of DP_QC_ENTITYDATA
		Provides information about the type of the field specified by the field num. Returns one of the EV_ values. */

string(float fieldnum, entity ent) getentityfieldstring = #499; /* Part of DP_QC_ENTITYDATA*/
float(float fieldnum, entity ent, string s) putentityfieldstring = #500; /* Part of DP_QC_ENTITYDATA*/
string(string filename, optional float makereferenced) whichpack = #503; /* Part of DP_QC_WHICHPACK
		Returns the pak file name that contains the file specified. progs/player.mdl will generally return something like 'pak0.pak'. If makereferenced is true, clients will automatically be told that the returned package should be pre-downloaded and used, even if allow_download_refpackages is not set. */

string(string in) uri_escape = #510; /* Part of DP_QC_URI_ESCAPE*/
string(string in) uri_unescape = #511; /* Part of DP_QC_URI_ESCAPE*/
float(entity ent) num_for_edict = #512;
#define uri_post uri_get
float(string uril, float id, optional string postmimetype, optional string postdata) uri_get = #513; /* Part of DP_QC_URI_GET, DP_QC_URI_POST
		uri_get() gets content from an URL and calls a callback "uri_get_callback" with it set as string; an unique ID of the transfer is returned
		returns 1 on success, and then calls the callback with the ID, 0 or the HTTP status code, and the received data in a string
		For a POST request, you will typically want the postmimetype set to application/x-www-form-urlencoded.
		For a GET request, omit the mime+data entirely.
		Consult your webserver/php/etc documentation for best-practise. */

float(string str) tokenize_console = #514; /*
		Tokenize a string exactly as the console's tokenizer would do so. The regular tokenize builtin became bastardized for convienient string parsing, which resulted in a large disparity that can be exploited to bypass checks implemented in a naive SV_ParseClientCommand function, therefore you can use this builtin to make sure it exactly matches. */

float(float idx) argv_start_index = #515; /*
		Returns the character index that the tokenized arg started at. */

float(float idx) argv_end_index = #516; /*
		Returns the character index that the tokenized arg stopped at. */

void(strbuf strbuf, string pattern, string antipattern) buf_cvarlist = #517;
string(string cvarname) cvar_description = #518; /*
		Retrieves the description of a cvar, which might be useful for tooltips or help files. This may still not be useful. */

float(float v, optional float base) log = #532; /* Part of ??MVDSV_BUILTINS
		Determines the logarithm of the input value according to the specified base. This can be used to calculate how much something was shifted by. */

float(string sample) soundlength = #534; /*
		Provides a way to query the duration of a sound sample, allowing you to set up a timer to chain samples. */

float(string filename, strbuf bufhandle) buf_loadfile = #535; /*
		Appends the named file into a string buffer (which must have been created in advance). The return value merely says whether the file was readable. */

float(filestream filehandle, strbuf bufhandle, optional float startpos, optional float numstrings) buf_writefile = #536; /*
		Writes the contents of a string buffer onto the end of the supplied filehandle (you must have already used fopen). Additional optional arguments permit you to constrain the writes to a subsection of the stringbuffer. */

void(float dest) setkeydest = #601;
float() getkeydest = #602;
void(float trg) setmousetarget = #603;
float() getmousetarget = #604;
void(.../*, string funcname*/) callfunction = #605; /*
		Invokes the named function. The function name is always passed as the last parameter and must always be present. The others are passed to the named function as-is */

void(filestream fh, entity e) writetofile = #606; /*
		Writes an entity's fields to the named frik_file file handle. */

float(string s) isfunction = #607; /*
		Returns true if the named function exists and can be called with the callfunction builtin. */

vector(float vidmode, optional float forfullscreen) getresolution = #608; /*
		Supposed to query the driver for supported video modes. FTE does not query drivers in this way, nor would it trust drivers anyway. */

string(float keynum) keynumtostring = #609; /*
		Converts a qscancode key number into a mostly-human-readable name, matching the bind command. */

string(string command, optional float bindmap) findkeysforcommand = #610;
float(float type) gethostcachevalue = #611; /* Part of FTE_CSQC_SERVERBROWSER*/
string(float type, float hostnr) gethostcachestring = #612; /* Part of FTE_CSQC_SERVERBROWSER*/
float(entity e, string s, optional float offset) parseentitydata = #613; /*
		Reads a single entity's fields into an already-spawned entity. s should contain field pairs like in a saved game: {"foo1" "bar" "foo2" "5"}. Returns <=0 on failure, otherwise returns the offset in the string that was read to. */

string(entity e) generateentitydata = #0:generateentitydata; /*
		Dumps the entities fields into a string which can later be parsed with parseentitydata. */

float(string key) stringtokeynum = #614; /*
		Returns the qscancode of a key from its name. Names are identical to the bind command. ctrl/shift/alt modifiers are ignored. */

void() resethostcachemasks = #615; /* Part of FTE_CSQC_SERVERBROWSER*/
void(float mask, float fld, string str, float op) sethostcachemaskstring = #616; /* Part of FTE_CSQC_SERVERBROWSER*/
void(float mask, float fld, float num, float op) sethostcachemasknumber = #617; /* Part of FTE_CSQC_SERVERBROWSER*/
void() resorthostcache = #618; /* Part of FTE_CSQC_SERVERBROWSER*/
void(float fld, float descending) sethostcachesort = #619; /* Part of FTE_CSQC_SERVERBROWSER*/
void(optional float dopurge) refreshhostcache = #620; /* Part of FTE_CSQC_SERVERBROWSER*/
float(float fld, float hostnr) gethostcachenumber = #621; /* Part of FTE_CSQC_SERVERBROWSER*/
float(string key) gethostcacheindexforkey = #622; /* Part of FTE_CSQC_SERVERBROWSER*/
void(string key) addwantedhostcachekey = #623; /* Part of FTE_CSQC_SERVERBROWSER*/
string() getextresponse = #624; /* Part of FTE_CSQC_SERVERBROWSER*/
string(string dnsname, optional float defport) netaddress_resolve = #625;
string(string fmt, ...) sprintf = #627; /* Part of DP_QC_SPRINTF
		'prints' to a formatted temp-string. Mostly acts as in C, however %d assumes floats (fteqcc has arg checking. Use it.).
		type conversions: l=arg is an int, h=arg is a float, and will work as a prefix for any float or int representation.
		float representations: d=decimal, e,E=exponent-notation, f,F=floating-point notation, g,G=terse float, c=char code, x,X=hex
		other representations: i=int, s=string, S=quoted and marked-up string, v=vector, p=pointer
		so %ld will accept an int arg, while %hi will expect a float arg.
		entities, fields, and functions will generally need to be printed as ints with %i. */

float(float key, string bind, optional float bindmap, optional float modifier) setkeybind = #630;
vector() getbindmaps = #631;
float(vector bm) setbindmaps = #632;
string(string digest, string data, ...) digest_hex = #639;
string(string digest, void *data, int length) digest_ptr = #0:digest_ptr; /*
		Calculates the digest of a single contiguous block of memory (including nulls) using the specified hash function. */

float(string src, string dst) fcopy = #650; /*
		Equivelent to fopen+fread+fwrite+fclose from QC (ie: reads from $gamedir/data/ or $gamedir, but always writes to $gamedir/data/ ) */

float(string src, string dst) frename = #651; /*
		Renames the file, returning 0 on success. Both paths are relative to the data/ subdir. */

float(string fname) fremove = #652; /*
		Deletes the named file - path is relative to data/ subdir, like fopen's FILE_WRITE. Returns 0 on success. */

float(string fname) fexists = #653; /*
		Use whichpack instead. Returns true if it exists inside the default writable path. */

float(string path) rmtree = #654; /*
		Dangerous, but sandboxed to data/ */

#if defined(CSQC) || defined(MENU)
#define K_TAB	9
#define K_ENTER	13
#define K_ESCAPE	27
#define K_SPACE	32
#define K_BACKSPACE	127
#define K_UPARROW	128
#define K_DOWNARROW	129
#define K_LEFTARROW	130
#define K_RIGHTARROW	131
#define K_LALT	132
#define K_RALT	-245
#define K_LCTRL	133
#define K_RCTRL	-246
#define K_LSHIFT	134
#define K_RSHIFT	-247
#define K_F1	135
#define K_F2	136
#define K_F3	137
#define K_F4	138
#define K_F5	139
#define K_F6	140
#define K_F7	141
#define K_F8	142
#define K_F9	143
#define K_F10	144
#define K_F11	145
#define K_F12	146
#define K_INS	147
#define K_DEL	148
#define K_PGDN	149
#define K_PGUP	150
#define K_HOME	151
#define K_END	152
#define K_KP_HOME	164
#define K_KP_UPARROW	165
#define K_KP_PGUP	166
#define K_KP_LEFTARROW	161
#define K_KP_5	162
#define K_KP_RIGHTARROW	163
#define K_KP_END	158
#define K_KP_DOWNARROW	159
#define K_KP_PGDN	160
#define K_KP_ENTER	172
#define K_KP_INS	157
#define K_KP_DEL	167
#define K_KP_SLASH	168
#define K_KP_MINUS	170
#define K_KP_PLUS	171
#define K_KP_NUMLOCK	154
#define K_KP_STAR	169
#define K_KP_EQUALS	173
#define K_MOUSE1	512
#define K_MOUSE2	513
#define K_MOUSE3	514
#define K_MOUSE4	517
#define K_MOUSE5	518
#define K_MOUSE6	519
#define K_MOUSE7	520
#define K_MOUSE8	521
#define K_MOUSE9	522
#define K_MOUSE10	523
#define K_MWHEELUP	515
#define K_MWHEELDOWN	516
#define K_LWIN	-239
#define K_RWIN	-240
#define K_APP	-241
#define K_SEARCH	-242
#define K_POWER	-130
#define K_VOLUP	-243
#define K_VOLDOWN	-244
#define K_JOY1	768
#define K_JOY2	769
#define K_JOY3	770
#define K_JOY4	771
#define K_AUX1	784
#define K_AUX2	785
#define K_AUX3	786
#define K_AUX4	787
#define K_AUX5	788
#define K_AUX6	789
#define K_AUX7	790
#define K_AUX8	791
#define K_AUX9	792
#define K_AUX10	793
#define K_AUX11	794
#define K_AUX12	795
#define K_AUX13	796
#define K_AUX14	797
#define K_AUX15	798
#define K_AUX16	799
#define K_AUX17	800
#define K_AUX18	801
#define K_AUX19	802
#define K_AUX20	803
#define K_AUX21	804
#define K_AUX22	805
#define K_AUX23	806
#define K_AUX24	807
#define K_AUX25	808
#define K_AUX26	809
#define K_AUX27	810
#define K_AUX28	811
#define K_AUX29	812
#define K_AUX30	813
#define K_AUX31	814
#define K_AUX32	815
#define K_PAUSE	153
#define K_PRINTSCREEN	174
#define K_CAPSLOCK	155
#define K_SCROLLLOCK	156
#define K_SEMICOLON	59
#define K_PLUS	43
#define K_MINUS	45
#define K_TILDE	126
#define K_BACKQUOTE	96
#define K_BACKSLASH	92
#define K_GP_A	826
#define K_GP_B	827
#define K_GP_X	828
#define K_GP_Y	829
#define K_GP_LSHOULDER	824
#define K_GP_RSHOULDER	825
#define K_GP_LTRIGGER	830
#define K_GP_RTRIGGER	831
#define K_GP_BACK	821
#define K_GP_START	820
#define K_GP_LTHUMB	822
#define K_GP_RTHUMB	823
#define K_GP_DPAD_UP	816
#define K_GP_DPAD_DOWN	817
#define K_GP_DPAD_LEFT	818
#define K_GP_DPAD_RIGHT	819
#define K_GP_GUIDE	-202
#define K_GP_UNKNOWN	-255
#define K_GP_LTHUMB_UP	832
#define K_GP_LTHUMB_DOWN	833
#define K_GP_LTHUMB_LEFT	834
#define K_GP_LTHUMB_RIGHT	835
#define K_GP_RTHUMB_UP	836
#define K_GP_RTHUMB_DOWN	837
#define K_GP_RTHUMB_LEFT	838
#define K_GP_RTHUMB_RIGHT	839
#endif
#ifdef _ACCESSORS
accessor strbuf : float
{
	inline get float asfloat[float idx] = {return stof(bufstr_get(this, idx));};
	inline set float asfloat[float idx] = {bufstr_set(this, idx, ftos(value));};
	get string[float] = bufstr_get;
	set string[float] = bufstr_set;
	get float length = buf_getsize;
};
accessor searchhandle : float
{
	get string[float] = search_getfilename;
	get float length = search_getsize;
};
accessor hashtable : float
{
	inline get vector v[string key] = {return hash_get(this, key, '0 0 0', EV_VECTOR);};
	inline set vector v[string key] = {hash_add(this, key, value, HASH_REPLACE|EV_VECTOR);};
	inline get string s[string key] = {return hash_get(this, key, "", EV_STRING);};
	inline set string s[string key] = {hash_add(this, key, value, HASH_REPLACE|EV_STRING);};
	inline get float f[string key] = {return hash_get(this, key, 0.0, EV_FLOAT);};
	inline set float f[string key] = {hash_add(this, key, value, HASH_REPLACE|EV_FLOAT);};
	inline get __variant[string key] = {return hash_get(this, key, __NULL__);};
	inline set __variant[string key] = {hash_add(this, key, value, HASH_REPLACE);};
};
accessor infostring : string
{
	get string[string] = infoget;
	inline set& string[string fld] = {this = infoadd(this, fld, value);};
};
accessor filestream : float
{
	get string = fgets;
	inline set string = {fputs(this,value);};
};
#endif
#pragma noref 0
